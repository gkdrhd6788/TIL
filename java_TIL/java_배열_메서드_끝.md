```java
int[] students; //배열 변수 선언
 students = new int[5]; //배열 생성
 //변수 값 대입
 students[0] = 90;
 students[1] = 80;
 students[2] = 70;
 students[3] = 60;
 students[4] = 50;

/*자바는 배열을 생성할 때 그 내부값을 자동
으로 초기화한다. 숫자는 0 , boolean 은 false , String 은 null (없다는 뜻이다.)로 초기화 된다.*/
```

new int[5] 로 배열을 생성하면 배열의 크기만큼 메모리를 확보한다. 

int 형을 5개 사용하면 4byte * 5 20byte 를 확보한다. 배열을 생성하고 나면 자바는 (메모리 어딘가에 있는 이) 배열에 접근할 수 있는 참조값(주소)( x001 )을 반환 한다. 선언한 배열 변수인 int[] students 에 생성된 배열의 참조값( x001 )을 보관한다.

```JAVA
int[] students = new int[5]; //1. 배열 생성
int[] students = x001; //2. new int[5]의 결과로 x001 참조값 반환
students = x001 //3. 최종 결과
```



기본형 vs 참조형
자바의 변수 데이터 타입을 가장 크게 보면 기본형과 참조형으로 분류할 수 있다. 사용하는 값을 직접 넣을 수 있는 기본
형, 그리고 방금 본 배열 변수와 같이 메모리의 참조값을 넣을 수 있는 참조형으로 분류할 수 있다.
기본형(Primitive Type): 우리가 지금까지 봤던 int , long , double , boolean 처럼 변수에 사용할
값을 직접 넣을 수 있는 데이터 타입을 기본형(Primitive Type)이라 한다.
참조형(Reference Type): int[] students 와 같이 데이터에 접근하기 위한 참조(주소)를 저장하는 데
이터 타입을 참조형(Reference Type)이라 한다. 뒤에서 학습하는 객체나 클래스를 담을 수 있는 변수들도 모두
참조형이다.



```java
//배열은 {} 를 사용해서 생성과 동시에 편리하게 초기화 하는 기능을 제공한다.
int[] students;
students = new int[]{90, 80, 70, 60, 50}; //배열 생성과 초기화(여기서는 []안에 X)

//심지어 이것도 가능하다.
int[] students = {90, 80, 70, 60, 50};
```

arr.length 는 행의 길이를 뜻한다.. {{},{}} 를 생각해보면 arr 배열은 {} , {} 2개의 배열 요소를 가진다

arr[row].length 는 열의 길이를 뜻한다.  arr[0] 은 {1,2,3} 배열을 뜻한다. 이 배열에는 3개의 요소가 있다





향상된 for문

인덱스 값을 직접 사용해야 하 는 경우에는 향상된 for문을 사용할 수 없다.



반환 타입이 있으면 반드시 값을 반환해야 한다.

반환 타입이 있는 메서드를 호출했는데 만약 반환 값이 필요없다면 사용하지 않아도 된다.

지금부터 자바에서 아주 중요한 대원칙 하나를 이야기하겠다. 밑줄 100번 긋자! 

자바는 항상 변수의 값을 복사해서 대입한다. 이런 차이점 외에는 변수 이름과 메서드 이름에 대한 규칙은 둘다 같다. 

변수 이름은 일반적으로 명사를 사용한다. 한편 메서드는 무언가 동작하는데 사용하기 때문에 일반적으로 동사로 시작 한다.

메서드 오버로딩

메서드의 이름이 같아도 매개변수의 타입 및 순서가 다르면 오버로딩을 할 수 있다. 참고로 반환 타입은 인정하지 않는 다.

메서드 시그니처는 자바에서 메서드를 구분할 수 있는 고유한 식별자나 서명을 뜻한다. 메서드 시그니처는 메서드의 이 름과 매개변수 타입(순서 포함)으로 구성

여기서 만약 다음 첫 번째 메서드를 삭제하면 어떻게 될까?

1: int 형 정수 1, int 형 정수 2를 호출했으므로 자동 형변환이 발생해서 add(double a, double b) 가 호출 된다. 2: 실수 1.2, 실수 1.5를 호출했으므로 add(double a, double b) 가 호출된다.

정리하면 먼저 본인의 타입에 최대한 맞는 메서드를 찾아서 실행하고, 그래도 없으면 형 변환 가능한 타입의 메서드를 찾아서 실행한다





