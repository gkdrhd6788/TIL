자바가 자동으로 생성해주시는 기본 생성자는 클래스와 같은 접근 제어자를 가진다
생성자도 접근 제어자 관점에서 메서드와 같다.



# 상속

* extends 대상은 하나만 선택할 수 있다.(자바는 다중 상속 금지)
* 화살표 방향은 내가 너를 안다!는 의미

* 용어 정리
  * 부모 클래스 (슈퍼 클래스): 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
  * 자식 클래스 (서브 클래스): 부모 클래스로부터 필드와 메서드를 상속받는 클래스

* 상속과 메모리 구조- 이 부분을 제대로 이해하는 것이 앞으로 정말 중요하다!
  * 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
  *  상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
  *  현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류 가 발생한다.

* 메서드 오버라이딩(재정의)
  * 부모에게서 상속 받은 기능을 자식이 재정의 하는 것\
  * @Override 애노테이션
    * 컴파일러는 이 애노테이션을 보고 메서드가 정확히 오버라이드 되었는지 확인한다. 오버라이딩 조건을 만족시키지 않으 면 컴파일 에러를 발생시킨다. 따라서 실수로 오버라이딩을 못하는 경우를 방지해준다. 예를 들어서 이 경우에 만약 부 모에 move() 메서드가 없다면 컴파일 오류가 발생한다. 참고로 이 기능은 필수는 아니지만 코드의 명확성을 위해 붙 여주는 것이 좋다.
  * 오버로딩(Overloading)과 오버라이딩(Overriding)
  * 메서드 오버라이딩 조건 
    * 메서드 이름: 메서드 이름이 같아야 한다. 
    * 메서드 매개변수(파라미터): 매개변수(파라미터) 타입, 순서, 개수가 같아야 한다.
    *  반환 타입: 반환 타입이 같아야 한다. 단 반환 타입이 하위 클래스 타입일 수 있다. 
    * static , final , private : 키워드가 붙은 메서드는 오버라이딩 될 수 없다. 
      * static 은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다. 쉽게 이 야기해서 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 된다.
      * final 메서드는 재정의를 금지한다.
      * private 메서드는 해당 클래스에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않는다. 따라서 오 버라이딩 할 수 없다. 
    * 생성자 오버라이딩: 생성자는 오버라이딩 할 수 없다.
    * 이하 아래는 참고만
    * 접근 제어자: 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안된다. 예를 들 어, 상위 클래스의 메서드가 protected 로 선언되어 있으면 하위 클래스에서 이를 public 또는 protected 로 오버라이드할 수 있지만, private 또는 default 로 오버라이드 할 수 없다. 
    * 예외: 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 throws 로 선언할 수 없다. 하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있다. 예외를 학습해야 이해할 수 있다. 예외는 뒤 에서 다룬다.