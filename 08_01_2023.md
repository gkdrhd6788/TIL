# 카운팅 정렬

- 배우기 전 : dict 사용

  ```python
  A = [0,4,1,4,1,2,4]
  cnt_dict = {}
  for key in A:
      if key in cnt_dict:
          cnt_dict[key] += 1
      else:
          cnt_dict[key] = 1
  print(cnt_dict)
  ```



* 정의: 

  - 각 항목이 몇 개 있는지 세는 작업을 하여 (카운팅), 선형 시간에 정렬 하는 효율적 알고리즘

  - 항목들의 순서를 결정하기 위함

    

* 제한 사항

  - 정수 or 정수로 표현 할 수 있는 자료에 대해서만 적용 [ ( 2 , 3 ), ( 4 , 2 ) ]도 가능

    이유 : 카운팅 하기 위해, 정수데이터를 카운트배열의 인덱스로 사용

  - 집합 내 가장 큰 정수를 알아야

    이유 : 카운트 배열의 충분한 공간 할당

    

* 카운팅 정렬 알고리즘

  ```python
  def counting_sort(A,B,k):
  # A [] -- 입력 배열
  # B [] -- 정렬된 배열
  # C [] -- 카운트 배열
      C = [0] * (k+1)  # 0부터 k까지이므로 k+1개의 칸이 필요
  
      for i in range(0,len(A)):   #각 숫자의 갯수 카운팅하기
          C[A[i]] += 1    # A[0]~A[n] 값이 C카운트 배열의 index가 된다.
  
      for i in range(1, len(C)):  #각 숫자까지의 카운팅 누적
          C[i] = C[i]+ C[i-1]     # i-1 =0 부터 시작되야 하므로 위에 range시작값이 1
  
      for i in range(len(A)-1,-1,-1):  # 거꾸로 탐색
          C[A[i]] = C[A[i]] - 1 # 각 숫자의 카운팅 누적 값을 B의 index로 설정하기위해
          B[C[A[i]]]= A[i]             # 입력 배열 값을 각 숫자의 뒤에서 부터 저장
  
      return B
  
  A=[0,4,1,3,1,2,4,1]
  B=[0]*len(A) # 이렇게 하는게 맞나?(질문)
  k=4
  print(counting_sort(A,B,k))
  ```



* 시간 복잡도 

  O(n+k) , n은 리스트 길이, k는 정수의 최대값(둘다 쓰는 이유 : n이 클지 k가 클지 모름)

  

* 기타

  (주의) 데이터의 크기 != 카운트의 크기





중복 가능한 순열

-  if 뺀다



탐욕알고리즘 (baby gin) 왜 이게 탐욕 알고리즘이지?

3 1 1 1 인 경우 런 트리플릿 조사 순서가 결과에 영향을 미침

더미 : 마지막 자리에서 트릿플릿과 런 둘다 검색하기위해(편의성)



숫자 한자리씩 알아내는 방법

뒤에꺼 부터 알아내기(%, //)



런인경우에도 같은자리로 간다(222인 경우) continue의 활용예 잘 보기

SWEA문제 연속한 1의 개수

split 안써도 되는 이유 

주의! 마지막 0111001111 잘 해보기





# 시간 복잡도 , 공간 복잡도

시간 - 실행시간, CPU 점유율

공간 - 메모리

시간, 공간을 둘 다 만족하기란 어렵다. 둘 중 하나 포기해야 (trade off관계)

