# To do

띄어쓰기 안되어 있는 인풋값 처리해보기

2차원 배열 왼쪽, 위에 0붙여보기, 4방향 모두 둘러쌓아보기

연습문제1

사칙 연산 강사님이 바꾼 코드 비교해서 보기

오늘 실습 - 암호 코드 스캔



# 핵심 사항

면접 질문: Big-Oh란? 점근적 상한이란? BFS란?

swea learn 의 advanced (파이썬 SW문제해결 응용_구현 - 07 그래프의 최소 비용 문제 까지 )

# Big-Oh (O) 

* O 표기는 복잡도의 **점근적 상한**을 나타낸다
* 다항식의 최고차항만 계수없이 취하면 된다.(빅오메가도 마찬가지)

* 점근적 상한이란? (중요)

​		 : n이 증가함에 따라 O(g(n))이 점근적 상한이라는 것

​		(즉, g(n)이  n0보다 큰 모든 n에 대해서 항상 f(n) 보다 크다는 것) (최악의 경우 최대치)

​	

* 비교 
  - Big -Omega : 복잡도의 점근적 하한
    - 이거보다 작을 수는 없다!
    - 최상의 경우 최소치(최소한 이만한 시간은 걸린다.)
  - Big-Theta
    - 빅오와 빅오메가 표기가 같은 경우에 사용한다.
    - 늘~

# 비트 연산

bit (비트): 메모리에서 상태를 구별할 수 있는 최소 단위

byte (바이트): 8개의 비트, 주소가 부여될 수 있음

프로그래밍의 기본

네트워크, 하드웨어에서 많이 쓰임(16진수 많이 쓰임)

## 연산자

* & (AND) : 비트단위로 AND 연산( 하나라도 0이면 0 )

  - ex. 0101

    ​      1010

  - 비트검사(비트 마스킹)에 쓰임
    - 그 자리가 1인지 0인지 확인--> 그 자리만 1로 해서 AND 검사(1이나오면 1맞음)

  - 특정비트만 0으로 만들고 싶을 때도 쓰임
    - 그 자리만 0으로 하고 AND 연산

  - 1<<n  특정비트만 1인값이 만들어짐(질문)
  - ~(1<<n) 특정비트만 0인 값이 만들어짐(질문)

* | (OR)
  - 하나라도 1이면 1
  - 특정 비트를 1로 만들고 싶을 때 쓰임
    - 그 자리만 1인값을 만들어서 OR 연산 (1<<n)

* ^ (XOR)

  - 같으면 0 다르면 1

  - 특정비트를 반전시키고 싶을 때 쓰임 ( 0 -> 1 or 1 -> 0 )  

    ex) 10110000 특정 위치 (4번째, 6번쨰)반전시키고 싶으면

    ​       00010100  과 XOR연산 (이거 만드는 법 ' 1<<5 | 1<<3 '  )

    ​       10000100  

* ~ (피연산자의 모든 비트를 반전시킨다.)

  특정비트가 아닌 모든 비트

  

* <<

  - 피연산자의 비트 열을 왼쪽으로 이동시킨다.
  - 특정비트를 1로 만들 때 쓰임
  - 1쉬프트 할 때마다 2를 곱하는 효과도 있음(질문)   

* ">>"  피 연산자의 비트 열을 오른 쪽으로 이동시킨다.
  - 1쉬프트 할 때마다 2로 나눠주는 효과도 있음(질문)



## 실습

* 1<< n
  - 2**n의 값을 갖는다.
  - 원소가 n개일 경우 모든 부분집합의 수
* i & ( 1 << j ) 
  - i의 j 번쨰 비트가 1인지 아닌지 확인
  - for j in range(0,N): 하면 i의 모든 비트 확인 (질문_결과값 확인)

```python
# 12918 

def Bbit_print(i): # binary
    output = ""
    for j in range(3,-1,-1):
        output+= "1" if i&(1<<j) else "0"
    print(output,end='')

dict = {"A":10,"B":11,"C":12,"D":13,"E":14,"F":15}


for tc in range(1, int(input())+1):
    N_str,hex_str=input().split()  # 4 47FE
    N = int(N_str)
    print(f"#{tc} ", end='')
    for ch in hex_str:
        '''
        if '0'<= ch <='9':  # without using dictionary
            val = ord(ch) - ord('0')
            Bbit_print(val)
        else: 
            val = 10 + ord(ch) - ord('A')
            Bbit_print(val)
        '''
        if ch in dict.keys():     # using dictionary
            Bbit_print(dict[ch])
        else:
            Bbit_print(int(ch))
    print()
```