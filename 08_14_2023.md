# 핵심 사항

IM 시험 : delta 중요(풍선팡, 과목평가1번 문제)

​	lab.ssafy에   https://lab.ssafy.com/s10/b01/02_algorithm/-/tree/master/IM_PASS

​	오목 판정 , 오셀로 게임



# 할 일

11620 백트래킹을 DFS로 구현

 계산기2,3



8/9 강의 다시 보기

DFS 재귀, [1,2,3]  두 개 이해하기

과목평가 2번 문제 풀기

비트 연산자 다시 이해하기 (8/2)

if -else 에서 else생략





# 오늘의 교훈

* 풍선팡 문제(=과목평가 1번 문제)

  - 나는,,,8개의 예외 케이스를 모두 작성함

  - 하지만,,

    ```python
    di = [-1, 0, 1, 0]
    dj = [0, 1, 0, -1]
    
    for tc in range(1, int(input())+1):
    
        N = int(input()) # 지도 가로세로 크기
        arr = [list(map(int,input().split())) for _ in range(N)]
        cnt = 0
        for i in range(N):
            for j in range(N):
                ifCenterHigh = True
                center = arr[i][j]  
                for k in range(4):  
                    ni, nj = i + di[k], j + dj[k] 
                    if (0<=ni<N) and (0<=nj<N): # 이렇게 하면 되었던것....
                        if arr[ni][nj] >= center:
                            ifCenterHigh = False
                            break  # indentation 안하면 이상한 값 나옴
                if ifCenterHigh:
                    cnt += 1
        print(f'#{tc} {cnt}')
    ```
    
  - flag안쓰고 for-else써도 됨
  
    ```# python
    di = [-1, 0, 1, 0]
    dj = [0, 1, 0, -1]
    
    for tc in range(1, int(input())+1):
        N = int(input()) 
        arr = [list(map(int,input().split())) for _ in range(N)]
        cnt = 0
        for i in range(N):
            for j in range(N):
                ifCenterHigh = True
                center = arr[i][j] 
                for k in range(4):  # 이렇게
                    ni, nj = i + di[k], j + dj[k]
                    if (0<=ni<N) and (0<=nj<N):
                        if arr[ni][nj] >= center:
                            break 
                else:	# 이렇게
                    cnt += 1
        print(f'#{tc} {cnt}')
    ```
  

```python
# 과목 평가 2번 문제 거의 풀었음

def perenCheck(str):  # 이상 없으면 None이 출력됨
    stack = []
    open_perenList = ['(','{']
    if str[0] not in open_perenList: # 처음에 괄호로 시작하는 지 체크
        return -1
    for ch in str:
        if ch in open_perenList:
            stack.append(ch)
        if ch == ')':
            if len(stack)==0:
                return -1
            elif stack.pop() != '(':
                return -1
        elif ch == '}':
            if len(stack)==0:
                return -1
            elif stack.pop() != '{':
                return -1
    if len(stack) == 0:
        return -1

def calculate(str):
    stack_cal = [0]*(len(str)+1)
    for ch in str:
        if ch == ')':
            plus = 0
            while True:
                before_value = stack_cal.pop()
                if before_value != '(':
                    plus += before_value
                else:
                    stack_cal.append(plus)
                    break

        elif ch == '}':
            multi = 1
            while True:
                before_value = stack_cal.pop()
                if before_value != '{' :
                    multi = multi* before_value
                else:
                    stack_cal.append(multi)
                    break

        else:
            if ch== '(' or ch== '{':
                stack_cal.append(ch)
            else:
                ch = int(ch)
                stack_cal.append(ch)

    return stack_cal


for tc in range(1, int(input())+1):
    str = input()
    if perenCheck(str) == -1:
        print(f'{tc} -1')
    else:
        print(f'{tc} {calculate(str)}')








```



----

# 계산기2

![image-20230814144344324](C:\Users\SSAFY\AppData\Roaming\Typora\typora-user-images\image-20230814144344324.png)

- 더 심플하게

![image-20230814144445266](C:\Users\SSAFY\AppData\Roaming\Typora\typora-user-images\image-20230814144445266.png)

# 계산기1

![image-20230814145130091](C:\Users\SSAFY\AppData\Roaming\Typora\typora-user-images\image-20230814145130091.png)



![image-20230814151216640](C:\Users\SSAFY\AppData\Roaming\Typora\typora-user-images\image-20230814151216640.png)

 

![image-20230814151310999](C:\Users\SSAFY\AppData\Roaming\Typora\typora-user-images\image-20230814151310999.png)

![image-20230814151357556](C:\Users\SSAFY\AppData\Roaming\Typora\typora-user-images\image-20230814151357556.png)



# 백트래킹

최적화, 결정 문제 해결

 DFS에서 시간초과 뜨면 백트래킹을 이용하라는 문제

## 미로 찾기

## n-queen

## 부분집합 구하기













-----강사님----

# 부분집합

## 일반

```python
```





## 재귀호출

```python
arr =[1,2,3]
N= 4
bits=[0]* N

def subset(k,n):
    if k == n:
        print(bits)
    else:
        for i in range(2):
            bit[k] = i
            subset(k+1,n)
            
subset(0,N)
```

```python
# 위에 for문 설명

bit[k] = 0
subset(k+1,n)

bit[k] = 1
subset(k+1,n)
```



# 순열

```python
arr = [1,2,3]
N = 3

for i in range(N): # 첫번째
    for j in range(N):
        if j == i :
            continue
        for k in range(N):
            if k ==i or k==j :
                continue
            print(arr[i],arr[j],arr[k])
            
            
```



```python
arr = [1.2.3]

N= 3
used =[0]*
lst = [0]*

def perm(k,n):
    if k == n:
        print(lst)
    else: 
        for i in range(N):
            lst[k] = arr[i]
            perm(k+1,n)
```

```python
# 재귀호출
def perm(k,n):
    if k == n:
        print(lst)
    else: 
        for i in range(N):
            if used[i]:
                continue
            used
            lst[k] = arr[i]
            perm(k+1,n)
```

# 조합

```python
# 야매 코드( 뽑고 싶은 갯수만큼 for 문을 돌린다.)
# 4개에서 3개를 뽑는다. 3C2 = 3
arr =[1,2,3,4]
N= 4

for i  in range(N):
    for j in range(1+1,N):
        for k in range(j+1, N):
            print(arr[i],arr[j],arr[k])
```



# 나누기

```python
N = 7
arr = [i for i in range(N)]

# 두 번 나누는 법
for i in range(1, N):
    print(arr[:i], arr[i:])
# 세 번 나누는 법    
for i in range(1, N-1):
    for j in range(i+1, N):
        print(arr[:i],arr[i:j],arr[j:])
```

