# TO DO

백준 - 블랙잭, 후보 추천, 종이자르기, 빙고

비트연산예제2,3,4 강의 다시듣고 이해하기(lab  ssafy에 코드 있음)

오늘 실습

​	Magnetic (IM수준)

​	암호코드 스캔

CS 스터디 공부하기

# 비트 연산 (자바 등에서 필요)

0x10 --16진수 표현

(질문) 

16진법 2자리가 1바이트. 1바이트는 이진수 8자리 

4개의 바이트->32개의 비트

* byte_ order (메모리 저장 시 연속되는 바이트가 저장되는 순서)

  - Big-endian(빅 엔디안) :  

    큰 단위가 앞에 나옴 . 빠른 주소에 높은 값 먼저 저장 및 전송. 네트워크에서 쓰임

  - Little-endian(리틀 엔디안) :

    반대. 대다수 데스크탑 컴퓨터

* 응용: 집합연산, 순열(DP에서 쓰임), byte_order



# 진수 ( 자바 등에서 필요 )

나누는 값보다 작은 몫이 나오면 멈추고 몫읽고 나머지를 역순으로 읽음

(10진수, 2진수 모두 마찬가지)

16진수는 2진수를 4자리씩 끊어서 쉽게 변환 가능(질문)

익숙해지는 방법 : 369게임을 2진수로 하면 익숙해짐

## 음수

- '2의 보수' 로 저장: 1의 보수(반전)의 최하위 비트에 1을 더한다. 자리올림이 발생할 수 있다. 
  - 사실 내 숫자보다 한자리 큰 2의 제곱수에서 뺀 값과 같음
  - 더하기 ,빼기등 연산이 가능해서 재미있음
  - -0이 따로 생기지 않음
  - Two's compliment

- 구분이 어려움(양수인지 음수인지) 앞쪽부터 다 1이 채워져있으면 음수겠거니 함. 



## 소수점 있을 때

* 실수형이라고 반드시 정밀해지는 게 아님

* 실수형의 오차
  - 2진수 0.0000 = 10진수 0 
  - 2진수 0.0001 = 10진수 0.0625
  - 위와 같이 2진수 소수점 4자리까지만 계산한다면 0.0601과 0.0610은 같은 값으로 취급됨.

- 실수형의 비교  (실수형의 오차 감안) (주의!!)
  - if a==b로 하면 안됨 (cf . 정수형)
  - if |c-d| < 10**-6(우리가 설정하는 정밀도) 이면 같은 거로 쳐~ 

* 연산 순서(오차 누적되지 않게 해야)
  - 정수로 만들고 계산 후 마지막에 소수점 찍는 방법도 있음

```python
# 음수가 포함된 나누기의 몫 (주의)

print( -5//2 )  # -3 (floor방식-작은 값으로 간다.)
print(int( -5/2 )) # -2 이걸 써야함
```



## 실수의 표현

* 부동 소수점(floating - point) 표기법 사용

  - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
  -  ex) 1001.0011 --> 1.0010011* (2**3) 
  - ex) 0.0011 --> 1.1*(2**-3)

* 지수부 표현: 익세스 표현(특이)

* 실수자료형의 유효자릿수(주의!!소숫점 아닌 부분까지 포함)

  - 32 비트 -> 6
  - 64  비트 -> 15

* 파이썬은 비트가 더 많아서 훨씬 넓은 범위의 실수 표현 가능

  

``` python
# 1241 암호코드 스캔

def Bbit_print(i): # binary
    output = ""
    for j in range(3,-1,-1):
        output+= "1" if i&(1<<j) else "0"
    return output

dict= {'A':10,'B':11,'C':12,'D':13,'E':14,'F':15} #2진수 변환시 필요
binary_str = ''  #2진수 변환후 저장
pswd_dict = {'211':0,'221':1,'122':2,'411':3,'132':4,'231':5,'114':6,'312':7,'213':8,'112':9} #암호 해독시 필요
eight_pwd_list = [] #암호 해독 후 저장

hex_num='000163589926345A3'  #입력 받을 값(임시)

for i in hex_num:
    if i in dict.keys(): #A,B,C인경우
        binary_str+=Bbit_print(dict[i])
    else: #1,2,3등인 경우
        binary_str+=Bbit_print(int(i))
binary_str=binary_str.rstrip('0')  #오른쪽 0제거하기


one_cnt = 0
zero_cnt = 0
cnt_list =[]
for i in range(len(binary_str)-1,-1,-1):

    num = binary_str[i]
    if num ==binary_str[i-1]: #앞 수랑 같을 때
        if num =='0':
            zero_cnt += 1
        else:
            one_cnt += 1
    else: #수가 바뀔 때
        if num == '1':
            one_cnt += 1
            cnt_list.append(one_cnt)
            one_cnt = 0
        else:  #0일 때
            zero_cnt += 1
            cnt_list.append(zero_cnt)
            zero_cnt = 0

        if len(cnt_list)==4:  # 암호 확인
            cnt_list.reverse()  #거꾸로 하기
            multi=min(cnt_list) #배수 구하기
            for i in range(4):  #배수로 나누기
                cnt_list[i] = cnt_list[i] // multi
            password = ''.join(map(str,cnt_list[1:4]))  #str, 맨 앞0의 갯수는 무시하기
            eight_pwd = pswd_dict[password]
            eight_pwd_list.append(eight_pwd)
            cnt_list = [] # 초기화
        if len(eight_pwd_list)==8:
            eight_pwd_list.reverse()
            break
print(eight_pwd_list)
```

