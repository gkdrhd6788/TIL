# 비트 연산 (자바 등에서 필요)

0x10 --16진수 표현

(질문) 

16진법 2자리가 1바이트. 1바이트는 이진수 8자리 

4개의 바이트->32개의 비트

* byte_ order (메모리 저장 시 연속되는 바이트가 저장되는 순서)

  - Big-endian(빅 엔디안) :  

    큰 단위가 앞에 나옴 . 빠른 주소에 높은 값 먼저 저장 및 전송. 네트워크에서 쓰임

  - Little-endian(리틀 엔디안) :

    반대. 대다수 데스크탑 컴퓨터

* 응용: 집합연산, 순열(DP에서 쓰임), byte_order



# 진수 ( 자바 등에서 필요 )

나누는 값보다 작은 몫이 나오면 멈추고 몫읽고 나머지를 역순으로 읽음

(10진수, 2진수 모두 마찬가지)

16진수는 2진수를 4자리씩 끊어서 쉽게 변환 가능(질문)

익숙해지는 방법 : 369게임을 2진수로 하면 익숙해짐

## 음수

- '2의 보수' 로 저장: 1의 보수(반전)의 최하위 비트에 1을 더한다. 자리올림이 발생할 수 있다. 
  - 사실 내 숫자보다 한자리 큰 2의 제곱수에서 뺀 값과 같음
  - 더하기 ,빼기등 연산이 가능해서 재미있음
  - -0이 따로 생기지 않음
  - Two's compliment

- 구분이 어려움(양수인지 음수인지) 앞쪽부터 다 1이 채워져있으면 음수겠거니 함. 



## 소수점 있을 때

* 실수형이라고 반드시 정밀해지는 게 아님

* 실수형의 오차
  - 2진수 0.0000 = 10진수 0 
  - 2진수 0.0001 = 10진수 0.0625
  - 위와 같이 2진수 소수점 4자리까지만 계산한다면 0.0601과 0.0610은 같은 값으로 취급됨.

- 실수형의 비교  (실수형의 오차 감안) (주의!!)
  - if a==b로 하면 안됨 (cf . 정수형)
  - if |c-d| < 10**-6(우리가 설정하는 정밀도) 이면 같은 거로 쳐~ 

* 연산 순서(오차 누적되지 않게 해야)
  - 정수로 만들고 계산 후 마지막에 소수점 찍는 방법도 있음

```python
# 음수가 포함된 나누기의 몫 (주의)

print( -5//2 )  # -3 (floor방식-작은 값으로 간다.)
print(int( -5/2 )) # -2 이걸 써야함
```



## 실수의 표현

* 부동 소수점(floating - point) 표기법 사용

  - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현
  -  ex) 1001.0011 --> 1.0010011* (2**3) 
  - ex) 0.0011 --> 1.1*(2**-3)

* 지수부 표현: 익세스 표현(특이)

* 실수자료형의 유효자릿수(주의!!소숫점 아닌 부분까지 포함)

  - 32 비트 -> 6
  - 64  비트 -> 15

* 파이썬은 비트가 더 많아서 훨씬 넓은 범위의 실수 표현 가능

  
